################################
##### Common Entities ##########
################################

enum ProductLifecycle {
  "The product is in the process of being initialized"
  INITIALIZING
  "The product is able to accept deposits and earn yield"
  RUNNING
  "A product can be paused for a variety of reasons, this is always to protect investors funds"
  PAUSED
}

"""
A token is a representation of a fungible asset on the blockchain
as specified by the ERC20 standard.
"""
type Token @entity(immutable: true) {
  # token address
  id: Bytes!

  "The token symbol"
  symbol: String
  "The token name"
  name: String
  "The number of decimals the token uses"
  decimals: BigInt!
}

"""
A transaction is a record of an event that happened on the blockchain.
Transactions are identified by their hash.
"""
type Transaction @entity(immutable: true) {
  "The transaction hash"
  id: Bytes!

  "The block number the transaction was included in"
  blockNumber: BigInt!
  "The timestamp of the block the transaction was included in"
  blockTimestamp: BigInt!

  "The address of the sender of the transaction"
  sender: Bytes!
}

"""
A clock tick is a record of time passing.
This is used to update the protocol's stats at regular intervals.
"""
type ClockTick @entity(immutable: true) {
  "truncated timestamp + tick period"
  id: Bytes!

  """
  Duration of the snapshot period in seconds.
  Available periods:
  - 15 minutes: 900
  - 1 day: 86400
  """
  period: BigInt!
  "Timestamp the tick was initiated at, rounded to period"
  roundedTimestamp: BigInt!
  "Actual timestamp tick was initiated at"
  timestamp: BigInt!
}

type Investor @entity {
  "The investor address"
  id: Bytes!
  "All investor beefy positions"
  positions: [ClmPosition!]! @derivedFrom(field: "investor")
  "All investor interactions"
  interactions: [ClmPositionInteraction!]! @derivedFrom(field: "investor")
}

"""
The Protocol entity is the main entity of the Beefy Finance subgraph.
It represents the Beefy Finance protocol.
This is where all stats and data about the protocol is stored.
"""
type Protocol @entity {
  """
  The protocol identifier:
  - 1: Beefy
  - 2: CLM
  """
  id: Bytes!

  "Protocol name"
  name: String!

  "All CLM in the protocol"
  clms: [CLM!]! @derivedFrom(field: "protocol")

  "All Classic in the protocol"
  classics: [Classic!]! @derivedFrom(field: "protocol")
}

#################################
##### Beefy Classic Contracts ###
#################################

"""
Beefy classic products are the original vaults and strategies.
Those are building on top of another prodocol like PancakeSwap, SushiSwap, etc.

TODO: find a better name for this entity
"""
type Classic @entity {
  "The vault address"
  id: Bytes!
  "The protocol the vault belongs to"
  protocol: Protocol!
  "The vault"
  vault: ClassicVault!
  "The vault strategy"
  strategy: ClassicStrategy!
  "The vault boosts"
  boosts: [ClassicBoost!]! @derivedFrom(field: "classic")

  "The current lifecycle status of the vault"
  lifecycle: ProductLifecycle!

  "The vault's share token"
  vaultSharesToken: Token!
  "The vault's underlying LP token"
  underlyingToken: Token!

  "The total supply of the vault shares token in circulation. Express with `sharesToken.decimals` decimals."
  vaultSharesTotalSupply: BigInt!

  "LP token price in native at the time of the interaction. Expressed with 18 decimals."
  underlyingToNativePrice: BigInt!
  "Native token price at the time of the interaction. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!

  "Amount of underlying tokens in the vault"
  underlyingAmount: BigInt!

  "All positions in the Classic"
  positions: [ClassicPosition!]! @derivedFrom(field: "classic")

  "All harvest events of the Classic"
  harvests: [ClassicHarvestEvent!]! @derivedFrom(field: "classic")

  "Snapshot of the Classic's stats"
  snapshots: [ClassicSnapshot!]! @derivedFrom(field: "classic")

  "All Classic interactions for this Classic"
  interactions: [ClassicPositionInteraction!]! @derivedFrom(field: "classic")
}

"""
A snapshot of the Classic's stats.
Any event that happens in the Classic is recorded in a snapshot.
We keep multiple snapshots time frames as noted by the "period" field.
Snapshots include: daily, weekly, yearly.
"""
type ClassicSnapshot @entity {
  "Classic.id + period + timestamp"
  id: Bytes!

  "The Classic the snapshot is for"
  classic: Classic!

  """
  Duration of the snapshot period in seconds.
  Available periods:
  - 1 day: 86400
  - 1 week: 604800
  - 1 year: 31536000
  """
  period: BigInt!
  "Timestamp the snapshot was initiated at, rounded to period"
  roundedTimestamp: BigInt!
  "Actual timestamp snapshot was initiated at"
  timestamp: BigInt!

  "The total supply of the vault shares token in circulation. Express with `sharesToken.decimals` decimals."
  vaultSharesTotalSupply: BigInt!

  "LP token price in native at the time of the interaction. Expressed with 18 decimals."
  underlyingToNativePrice: BigInt!
  "Native token price at the time of the interaction. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!

  "Amount of underlying tokens in the vault"
  underlyingAmount: BigInt!
}

"""
A vault is a contract that manages the assets of a Beefy product.
This entity is mostly used to start tracking the events and link them to the Beefy product on new event
"""
type ClassicVault @entity {
  "The strategy address"
  id: Bytes!
  "The classic product the vault belongs to"
  classic: Classic!
  "The transaction that created the strategy"
  createdWith: Transaction!
  "Technical field to remember if the strategy was already initialized"
  isInitialized: Boolean!
}

"""
A strategy is a contract that manages the assets of a Beefy product.
This entity is mostly used to start tracking the events and link them to the Beefy product on new event
"""
type ClassicStrategy @entity {
  "The strategy address"
  id: Bytes!
  "The classic product the strategy belongs to"
  classic: Classic!
  "The vault the strategy is managing"
  vault: ClassicVault!
  "The transaction that created the strategy"
  createdWith: Transaction!
  "Technical field to remember if the strategy was already initialized"
  isInitialized: Boolean!
}

"""
A boost is a contract that manages the assets of a Beefy product.
This entity is mostly used to start tracking the events and link them to the Beefy product on new event
"""
type ClassicBoost @entity {
  "The boost address"
  id: Bytes!
  "The classic product the strategy belongs to"
  classic: Classic!
  "The vault the boost is managing"
  vault: ClassicVault!
  "The transaction that created the strategy"
  createdWith: Transaction!
  "Technical field to remember if the strategy was already initialized"
  isInitialized: Boolean!
}

"""
Classic products are harvested by the strategy. This event is emitted when the strategy harvests the vault.
"""
type ClassicHarvestEvent @entity(immutable: true) {
  "transaction hash + log index"
  id: Bytes!

  "The Classic the harvest event is for"
  classic: Classic!
  "The strategy that harvested the vault"
  strategy: ClassicStrategy!

  "The transaction that created the harvest event"
  createdWith: Transaction!

  "The event log index in the transaction that created the harvest event."
  logIndex: BigInt!

  "The timestamp of the harvest event so you can sort by time"
  timestamp: BigInt!

  "Underlying balance after the harvest"
  underlyingAmount: BigInt!
  "The amount of underlying tokens compounded"
  compoundedAmount: BigInt!

  "Total amount of liquidity in the vault at time of harvest"
  vaultSharesTotalSupply: BigInt!

  "LP token price in native at the time of the interaction. Expressed with 18 decimals."
  underlyingToNativePrice: BigInt!
  "Native token price at the time of the interaction. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!
}

"""
This event is emitted when we collect earned trading fees from the underlying pool.
"""
type ClassicPosition @entity {
  "Classic.id + investor address"
  id: Bytes!

  "The Classic the investor has a position in"
  classic: Classic!
  "The investor that has a position in the Classic"
  investor: Investor!
  "The transaction that created the investor position"
  createdWith: Transaction!

  "The amount of vault shares the investor holds directly"
  vaultBalance: BigInt!
  "The amount of vault shares the investor holds in a boost"
  boostBalance: BigInt!
  "Total amount of vault shares the investor holds. Should always equal vaultBalance + boostBalance. This is mostly used for filtering."
  totalBalance: BigInt!

  "All investor position interactions"
  interactions: [ClassicPositionInteraction!]! @derivedFrom(field: "investorPosition")
}

enum ClassicPositionInteractionType {
  "The investor deposited funds into the vault"
  VAULT_DEPOSIT
  "The investor withdrew funds from the vault"
  VAULT_WITHDRAW
  "The investor staked in the boost of the vault and received boost shares"
  BOOST_STAKE
  "The investor unstaked from the boost of the vault and received vault shares"
  BOOST_UNSTAKE
}

type ClassicPositionInteraction @entity(immutable: true) {
  "transaction hash + event log index"
  id: Bytes!

  "The Classic the investor has a position in"
  classic: Classic!
  "The investor that has a position in the Classic"
  investor: Investor!
  "The investor position the interaction is for"
  investorPosition: ClassicPosition!

  "The transaction that created the investor position interaction"
  createdWith: Transaction!

  "Block number of the interaction"
  blockNumber: BigInt!
  "The timestamp of the interaction"
  timestamp: BigInt!

  "The type of the interaction"
  type: ClassicPositionInteractionType!

  "The amount of vault shares the investor holds directly at the time of the interaction"
  vaultBalance: BigInt!
  "The amount of vault shares the investor holds in a boost at the time of the interaction"
  boostBalance: BigInt!
  "Total amount of vault shares the investor holds. Should always equal vaultBalance + boostBalance. This is mostly used for filtering."
  totalBalance: BigInt!

  "Amount of vault shares change in the interaction"
  vaultBalanceDelta: BigInt!
  "Amount of boost shares change in the interaction"
  boostBalanceDelta: BigInt!

  "LP token price in native at the time of the interaction. Expressed with 18 decimals."
  underlyingToNativePrice: BigInt!
  "Native token price at the time of the interaction. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!
}

#######################
##### CLM Contracts ###
#######################

type CLM @entity {
  "The CL Manager address"
  id: Bytes!

  "The protocol the CLM belongs to"
  protocol: Protocol!
  "The manager of the CLM. The manager is responsible for accounting of a CLM."
  manager: ClmManager!
  "The strategy of the CLM. The strategy is responsible for managing the CLM's assets."
  strategy: ClmStrategy!
  "The reward pool of the CLM. The reward pool is where the CLM's earnings are sent if the ClmManager does not automatically compound."
  rewardPool: ClmRewardPool

  "The current lifecycle status of the CLM"
  lifecycle: ProductLifecycle!

  "The manager token data of the CLM. The ClmManager is also an ERC20 token. This tokens represents the shares of the manager."
  managerToken: Token!
  "The reward pool token of the CLM. This is where the CLM's earnings are sent if the CLM does not automatically compound."
  rewardPoolToken: Token!

  "The underlying tokens contained in the CLM. This is the first token."
  underlyingToken0: Token!
  "The underlying tokens contained in the CLM. This is the second token."
  underlyingToken1: Token!
  "The reward tokens of the CLM's rewardpool. These will be rewarded to positions when the CLM earns non-compounding yield."
  rewardTokens: [Token!]!

  # ----- PRICES & STATS -----

  "The total supply of the CLM shares token in circulation. Express with `managerToken.decimals` decimals."
  managerTotalSupply: BigInt!
  "Total supply of the reward pool token. Express with `rewardPoolToken.decimals` decimals."
  rewardPoolTotalSupply: BigInt!

  "Latest token 0 price in native we have seen. Expressed with 18 decimals."
  token0ToNativePrice: BigInt!
  "Latest token 1 price in native we have seen. Expressed with 18 decimals."
  token1ToNativePrice: BigInt!
  "Latest reward token prices in native we have seen. Ordered by clm.rewardTokens. Expressed with 18 decimals."
  rewardToNativePrices: [BigInt!]!
  "Latest native token price we have seen. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!

  """
  The current price of the token zero expressed as a token1 value.
  For example, if the CLM is a BTC/ETH CLM, this is the price of 1 BTC in ETH.
  This is expressed in token1 decimals.
  """
  priceOfToken0InToken1: BigInt!
  "Price range start this CLM is currently configured to operate in, in token 1"
  priceRangeMin1: BigInt!
  "Price range end this CLM is currently configured to operate in, in token 1"
  priceRangeMax1: BigInt!

  "Amount of underlying tokens in the CLM assigned to the main position in the first token."
  underlyingMainAmount0: BigInt!
  "Amount of underlying tokens in the CLM assigned to the main position in the second token."
  underlyingMainAmount1: BigInt!
  "Amount of underlying tokens in the CLM assigned to the alt position in the first token."
  underlyingAltAmount0: BigInt!
  "Amount of underlying tokens in the CLM assigned to the alt position in the second token."
  underlyingAltAmount1: BigInt!

  "All positions in the CLM"
  positions: [ClmPosition!]! @derivedFrom(field: "clm")

  "All collections events by the CLM"
  collections: [ClmManagerCollectionEvent!]! @derivedFrom(field: "clm")

  "All harvest events of the CLM"
  harvests: [ClmHarvestEvent!]! @derivedFrom(field: "clm")

  "Snapshot of the CLM's stats"
  snapshots: [ClmSnapshot!]! @derivedFrom(field: "clm")

  "All CLM interactions for this CLM"
  interactions: [ClmPositionInteraction!]! @derivedFrom(field: "clm")
}

"""
A snapshot of the CLM's stats.
Any event that happens in the CLM is recorded in a snapshot.
We keep multiple snapshots time frames as noted by the "period" field.
Snapshots include: daily, weekly, yearly.
"""
type ClmSnapshot @entity {
  "CLM.id + period + timestamp"
  id: Bytes!

  "The CLM the snapshot is for"
  clm: CLM!

  """
  Duration of the snapshot period in seconds.
  Available periods:
  - 1 day: 86400
  - 1 week: 604800
  - 1 year: 31536000
  """
  period: BigInt!
  "Timestamp the snapshot was initiated at, rounded to period"
  roundedTimestamp: BigInt!
  "Actual timestamp snapshot was initiated at"
  timestamp: BigInt!

  "The total supply of the manager token in circulation. Express with `sharesToken.decimals` decimals."
  managerTotalSupply: BigInt!
  "Total supply of the reward pool token. Express with `rewardPoolToken.decimals` decimals."
  rewardPoolTotalSupply: BigInt!

  "Latest token 0 price in native of this snapshot. Expressed with 18 decimals."
  token0ToNativePrice: BigInt!
  "Latest token 1 price in native of this snapshot. Expressed with 18 decimals."
  token1ToNativePrice: BigInt!
  "Latest reward token prices in native of this snapshot. Ordered by clm.rewardTokens. Expressed with 18 decimals."
  rewardToNativePrices: [BigInt!]!
  "Latest native token price of this snapshot. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!

  """
  The current price of the token zero expressed as a token1 value.
  For example, if the CLM is a BTC/ETH CLM, this is the price of 1 BTC in ETH.
  This is expressed in token1 decimals.
  """
  priceOfToken0InToken1: BigInt!
  "Price range start this CLM is currently configured to operate in, in token 1"
  priceRangeMin1: BigInt!
  "Price range end this CLM is currently configured to operate in, in token 1"
  priceRangeMax1: BigInt!

  "Amount of underlying tokens in the CLM assigned to the main position in the first token."
  underlyingMainAmount0: BigInt!
  "Amount of underlying tokens in the CLM assigned to the main position in the second token."
  underlyingMainAmount1: BigInt!
  "Amount of underlying tokens in the CLM assigned to the alt position in the first token."
  underlyingAltAmount0: BigInt!
  "Amount of underlying tokens in the CLM assigned to the alt position in the second token."
  underlyingAltAmount1: BigInt!
}

"""
A ClmManager handles the accounting of a CLM.
"""
type ClmManager @entity {
  "The CL Manager address"
  id: Bytes!
  "The CLM this manager belongs to"
  clm: CLM!
  "The transaction that created the manager"
  createdWith: Transaction!
  "Technical field to remember if the CLM was already initialized"
  isInitialized: Boolean!
}

"""
A strategy is a contract that manages the assets of a CLM.
This entity is mostly used to start tracking the events and link them to the CLM on new event
"""
type ClmStrategy @entity {
  "The strategy address"
  id: Bytes!
  "The CLM the strategy is managing"
  clm: CLM!
  "The manager of the strategy"
  manager: ClmManager!
  "The transaction that created the strategy"
  createdWith: Transaction!
  "Technical field to remember if the strategy was already initialized"
  isInitialized: Boolean!
}

"""
Some ClmManager do not automatically compound their earnings. Those earnings are sent to the reward pool instead.
This entity is mostly used to start tracking the events and link them to the CLM on new event
"""
type ClmRewardPool @entity {
  "The strategy address"
  id: Bytes!
  "The CLM the reward pool is for"
  clm: CLM!
  "The manager that this reward pool is linked to"
  manager: ClmManager!
  "The transaction that created the reward pool"
  createdWith: Transaction!
  "Technical field to remember if the strategy was already initialized"
  isInitialized: Boolean!
}

"""
ClmManagers are harvested by the strategy. This event is emitted when the strategy harvests the manager.
"""
type ClmHarvestEvent @entity(immutable: true) {
  "transaction hash + log index"
  id: Bytes!

  "The CLM the harvest event is for"
  clm: CLM!
  "The strategy that harvested the Manager"
  strategy: ClmStrategy!

  "The transaction that created the harvest event"
  createdWith: Transaction!

  "The event log index in the transaction that created the harvest event."
  logIndex: BigInt!

  "The timestamp of the harvest event so you can sort by time"
  timestamp: BigInt!

  "Underlying balance of the first token after the harvest"
  underlyingAmount0: BigInt!
  "Underlying balance of the second token after the harvest"
  underlyingAmount1: BigInt!

  "The amount of first underlying tokens compounded"
  compoundedAmount0: BigInt!
  "The amount of second underlying tokens compounded"
  compoundedAmount1: BigInt!
  "The amount of reward tokens collected. Ordered by clm.rewardTokens."
  collectedRewards: [BigInt!]!

  "Total amount of liquidity in the manager at time of harvest"
  managerTotalSupply: BigInt!
  "Total amount of reward pool shares at time of harvest"
  rewardPoolTotalSupply: BigInt!

  "Token 0 price in native at the time of harvest. Expressed with 18 decimals."
  token0ToNativePrice: BigInt!
  "Token 1 price in native at the time of harvest. Expressed with 18 decimals."
  token1ToNativePrice: BigInt!
  "Reward token prices in native at the time of harvest. Expressed with 18 decimals. Ordered by clm.rewardTokens."
  rewardToNativePrices: [BigInt!]!
  "Native token price at the time of harvest. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!
}

"""
This event is emitted when we collect earned trading fees from the underlying pool.
"""
type ClmManagerCollectionEvent @entity(immutable: true) {
  "transaction hash + log index"
  id: Bytes!

  "The CLM the collect event is for"
  clm: CLM!
  "The strategy that collect for the Manager"
  strategy: ClmStrategy!

  "The transaction that created the collect event"
  createdWith: Transaction!

  "The event log index in the transaction that created the collection event."
  logIndex: BigInt!

  "The timestamp of the collect event so you can sort by time"
  timestamp: BigInt!

  "Amount of underlying tokens in the CLM assigned to the main position in the first token."
  underlyingMainAmount0: BigInt!
  "Amount of underlying tokens in the CLM assigned to the main position in the second token."
  underlyingMainAmount1: BigInt!
  "Amount of underlying tokens in the CLM assigned to the alt position in the first token."
  underlyingAltAmount0: BigInt!
  "Amount of underlying tokens in the CLM assigned to the alt position in the second token."
  underlyingAltAmount1: BigInt!

  "Amount of collected fees in the first token"
  collectedAmount0: BigInt!
  "Amount of collected fees in the second token"
  collectedAmount1: BigInt!
  "Amount of collected fees in the reward tokens. Ordered by clm.rewardTokens."
  collectedRewardAmounts: [BigInt!]!

  "Token 0 price in native at the time of the collection. Expressed with 18 decimals."
  token0ToNativePrice: BigInt!
  "Token 1 price in native at the time of the collection. Expressed with 18 decimals."
  token1ToNativePrice: BigInt!
  "Reward token prices in native at the time of the collection. Expressed with 18 decimals. Ordered by clm.rewardTokens."
  rewardToNativePrices: [BigInt!]!
  "Native token price at the time of the interaction. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!
}

"""
An investor position is a record of an investor's position in a CLM.
"""
type ClmPosition @entity {
  "CLM.id + investor address"
  id: Bytes!

  "The CLM the investor has a position in"
  clm: CLM!
  "The investor that has a position in the CLM"
  investor: Investor!
  "The transaction that created the investor position"
  createdWith: Transaction!

  "The amount of manager shares the investor holds"
  managerBalance: BigInt!
  "Amount of reward pool shares the investor holds"
  rewardPoolBalance: BigInt!
  "Total amount of CLM shares the investor holds. Should always equal to managerBalance + rewardPoolBalance. This is mostly used for filtering."
  totalBalance: BigInt!

  "All investor position interactions"
  interactions: [ClmPositionInteraction!]! @derivedFrom(field: "investorPosition")
}

enum ClmPositionInteractionType {
  "The investor deposited funds into the CLM"
  MANAGER_DEPOSIT
  "The investor withdrew funds from the CLM"
  MANAGER_WITHDRAW
  "The investor staked in the reward pool of the CLM and received reward pool shares"
  REWARD_POOL_STAKE
  "The investor unstaked from the reward pool of the CLM and received underlying tokens"
  REWARD_POOL_UNSTAKE
  "The investor claimed their rewards from the reward pool of the CLM"
  REWARD_POOL_CLAIM
}

type ClmPositionInteraction @entity(immutable: true) {
  "transaction hash + event log index"
  id: Bytes!

  "The CLM the investor has a position in"
  clm: CLM!
  "The investor that has a position in the CLM"
  investor: Investor!
  "The investor position the interaction is for"
  investorPosition: ClmPosition!

  "The transaction that created the investor position interaction"
  createdWith: Transaction!

  "Block number of the interaction"
  blockNumber: BigInt!
  "The timestamp of the interaction"
  timestamp: BigInt!

  "The type of the interaction"
  type: ClmPositionInteractionType!

  "The amount of manager shares the investor holds at the time of the interaction"
  managerBalance: BigInt!
  "The amount of reward pool shares the investor holds at the time of the interaction"
  rewardPoolBalance: BigInt!
  "Total amount of CLM shares the investor holds. Should always equal to managerBalance + rewardPoolBalance. This is mostly used for filtering."
  totalBalance: BigInt!
  "The amount of first underlying tokens the investor is entitled to at the time of the interaction"
  underlyingBalance0: BigInt!
  "The amount of second underlying tokens the investor is entitled to at the time of the interaction"
  underlyingBalance1: BigInt!

  "Amount of manager shares change in the interaction"
  managerBalanceDelta: BigInt!
  "Amount of reward pool shares change in the interaction"
  rewardPoolBalanceDelta: BigInt!
  "Amount of reward tokens change in the interaction. Ordered by clm.rewardTokens."
  rewardBalancesDelta: [BigInt!]!
  "Amount of underlying token 0 change in the interaction"
  underlyingBalance0Delta: BigInt!
  "Amount of underlying token 0 change in the interaction"
  underlyingBalance1Delta: BigInt!

  "Token 0 price in native at the time of the interaction. Expressed with 18 decimals."
  token0ToNativePrice: BigInt!
  "Token 1 price in native at the time of the interaction. Expressed with 18 decimals."
  token1ToNativePrice: BigInt!
  "Reward token prices in native at the time of the interaction. Expressed with 18 decimals. Ordered by clm.rewardTokens."
  rewardToNativePrices: [BigInt!]!
  "Native token price at the time of the interaction. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!
}
