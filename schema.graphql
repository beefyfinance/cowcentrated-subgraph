################################
##### Common Entities ##########
################################

enum ProductLifecycle {
  "The product is in the process of being initialized"
  INITIALIZING
  "The product is able to accept deposits and earn yield"
  RUNNING
  "A product can be paused for a variety of reasons, this is always to protect investors funds"
  PAUSED
}

"""
A token is a representation of a fungible asset on the blockchain
as specified by the ERC20 standard.
"""
type Token @entity(immutable: true) {
  # token address
  id: Bytes!

  "The token symbol"
  symbol: String
  "The token name"
  name: String
  "The number of decimals the token uses"
  decimals: BigInt!
}

"""
A transaction is a record of an event that happened on the blockchain.
Transactions are identified by their hash.
"""
type Transaction @entity(immutable: true) {
  "The transaction hash"
  id: Bytes!

  "The block number the transaction was included in"
  blockNumber: BigInt!
  "The timestamp of the block the transaction was included in"
  blockTimestamp: BigInt!

  "The address of the sender of the transaction"
  sender: Bytes!
}

"""
A clock tick is a record of time passing.
This is used to update the protocol's stats at regular intervals.
"""
type ClockTick @entity(immutable: true) {
  "truncated timestamp + tick period"
  id: Bytes!

  """
  Duration of the snapshot period in seconds.
  Available periods:
  - 15 minutes: 900
  - 1 day: 86400
  """
  period: BigInt!
  "Timestamp the tick was initiated at, rounded to period"
  roundedTimestamp: BigInt!
  "Actual timestamp tick was initiated at"
  timestamp: BigInt!
}

type Investor @entity {
  "The investor address"
  id: Bytes!
  "All investor beefy positions"
  positions: [ClmPosition!]! @derivedFrom(field: "investor")
  "All investor interactions"
  interactions: [ClmPositionInteraction!]! @derivedFrom(field: "investor")
}

"""
The Protocol entity is the main entity of the Beefy Finance subgraph.
It represents the Beefy Finance protocol.
This is where all stats and data about the protocol is stored.
"""
type Protocol @entity {
  """
  The protocol identifier:
  - 1: Beefy
  - 2: CLM
  """
  id: Bytes!

  "Protocol name"
  name: String!

  "All CLM in the protocol"
  clms: [CLM!]! @derivedFrom(field: "protocol")

  "All Classic in the protocol"
  classics: [Classic!]! @derivedFrom(field: "protocol")
}

#################################
##### Beefy Classic Contracts ###
#################################

"""
Beefy classic products are the original vaults and strategies.
Those are building on top of another prodocol like PancakeSwap, SushiSwap, etc.

TODO: find a better name for this entity
"""
type Classic @entity {
  "The vault address"
  id: Bytes!

  "The protocol the vault belongs to"
  protocol: Protocol!
  "The vault"
  vault: ClassicVault!
  "The vault strategy"
  strategy: ClassicStrategy!
  "The vault boosts"
  boosts: [ClassicBoost!]! @derivedFrom(field: "classic")

  "The current lifecycle status of the vault"
  lifecycle: ProductLifecycle!

  "The vault's share token"
  vaultSharesToken: Token!

  "The vault's underlying LP token"
  underlyingToken: Token!

  "The boost tokens of the vault. Tokens earned by staking in the boost."
  boostRewardTokens: [Token!]!
  "The boost token addresses of the vault. This is the source of truth for other tables reward ordering."
  boostRewardTokensOrder: [Bytes!]!

  # ----- PRICES & STATS -----

  "The total supply of the vault shares token in circulation. Express with `sharesToken.decimals` decimals."
  vaultSharesTotalSupply: BigInt!

  "Latest LP token price in native we have seen. Expressed with 18 decimals."
  underlyingToNativePrice: BigInt!
  "Latest boost token prices in native we have seen. Ordered by classic.boostRewardTokensOrder. Expressed with 18 decimals."
  boostRewardToNativePrices: [BigInt!]!
  "Latest native token price we have seen. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!

  "Amount of underlying token in the vault"
  underlyingAmount: BigInt!

  "All positions in the Classic"
  positions: [ClassicPosition!]! @derivedFrom(field: "classic")

  "All harvest events of the Classic"
  harvests: [ClassicHarvestEvent!]! @derivedFrom(field: "classic")

  "Snapshot of the Classic's stats"
  snapshots: [ClassicSnapshot!]! @derivedFrom(field: "classic")

  "All Classic interactions for this Classic"
  interactions: [ClassicPositionInteraction!]! @derivedFrom(field: "classic")
}

"""
A snapshot of the Classic's stats.
Any event that happens in the Classic is recorded in a snapshot.
We keep multiple snapshots time frames as noted by the "period" field.
Snapshots include: daily, weekly, yearly.
"""
type ClassicSnapshot @entity {
  "Classic.id + period + timestamp"
  id: Bytes!

  "The Classic the snapshot is for"
  classic: Classic!

  """
  Duration of the snapshot period in seconds.
  Available periods:
  - 1 day: 86400
  - 1 week: 604800
  - 1 year: 31536000
  """
  period: BigInt!
  "Timestamp the snapshot was initiated at, rounded to period"
  roundedTimestamp: BigInt!
  "Actual timestamp snapshot was initiated at"
  timestamp: BigInt!

  "The total supply of the vault shares token in circulation. Express with `sharesToken.decimals` decimals."
  vaultSharesTotalSupply: BigInt!

  "Latest LP token price in native of this snapshot. Expressed with 18 decimals."
  underlyingToNativePrice: BigInt!
  "Latest boost token prices in native of this snapshot. Ordered by classic.boostRewardTokensOrder. Expressed with 18 decimals."
  boostRewardToNativePrices: [BigInt!]!
  "Latest native token price of this snapshot. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!

  "Amount of underlying tokens in the vault"
  underlyingAmount: BigInt!
}

"""
A vault is a contract that manages the assets of a Beefy product.
This entity is mostly used to start tracking the events and link them to the Beefy product on new event
"""
type ClassicVault @entity {
  "The strategy address"
  id: Bytes!
  "The classic product the vault belongs to"
  classic: Classic!
  "The transaction that created the strategy"
  createdWith: Transaction!
  "Technical field to remember if the strategy was already initialized"
  isInitialized: Boolean!
}

"""
A strategy is a contract that manages the assets of a Beefy product.
This entity is mostly used to start tracking the events and link them to the Beefy product on new event
"""
type ClassicStrategy @entity {
  "The strategy address"
  id: Bytes!
  "The classic product the strategy belongs to"
  classic: Classic!
  "The vault the strategy is managing"
  vault: ClassicVault!
  "The transaction that created the strategy"
  createdWith: Transaction!
  "Technical field to remember if the strategy was already initialized"
  isInitialized: Boolean!
}

"""
A boost is a contract that manages the assets of a Beefy product.
This entity is mostly used to start tracking the events and link them to the Beefy product on new event
"""
type ClassicBoost @entity {
  "The boost address"
  id: Bytes!
  "The classic product the strategy belongs to"
  classic: Classic!
  "The vault the boost is managing"
  vault: ClassicVault!
  "The transaction that created the strategy"
  createdWith: Transaction!
  "The boost reward token"
  rewardToken: Token!
  "Technical field to remember if the strategy was already initialized"
  isInitialized: Boolean!
}

"""
Classic products are harvested by the strategy. This event is emitted when the strategy harvests the vault.
"""
type ClassicHarvestEvent @entity(immutable: true) {
  "transaction hash + log index"
  id: Bytes!

  "The Classic the harvest event is for"
  classic: Classic!
  "The strategy that harvested the vault"
  strategy: ClassicStrategy!

  "The transaction that created the harvest event"
  createdWith: Transaction!

  "The event log index in the transaction that created the harvest event."
  logIndex: BigInt!

  "The timestamp of the harvest event so you can sort by time"
  timestamp: BigInt!

  "Underlying balance after the harvest"
  underlyingAmount: BigInt!
  "The amount of underlying tokens compounded"
  compoundedAmount: BigInt!

  "Total amount of liquidity in the vault at time of harvest"
  vaultSharesTotalSupply: BigInt!

  "LP token price in native at the time of harvest. Expressed with 18 decimals."
  underlyingToNativePrice: BigInt!
  "Boost token prices in native at the time of harvest. Ordered by classic.boostRewardTokensOrder. Expressed with 18 decimals."
  boostRewardToNativePrices: [BigInt!]!
  "Native token price at the time of harvest. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!
}

"""
This event is emitted when we collect earned trading fees from the underlying pool.
"""
type ClassicPosition @entity {
  "Classic.id + investor address"
  id: Bytes!

  "The Classic the investor has a position in"
  classic: Classic!
  "The investor that has a position in the Classic"
  investor: Investor!
  "The transaction that created the investor position"
  createdWith: Transaction!

  "The amount of vault shares the investor holds directly"
  vaultBalance: BigInt!
  "The amount of vault shares the investor holds in a boost"
  boostBalance: BigInt!
  "Total amount of vault shares the investor holds. Should always equal vaultBalance + boostBalance. This is mostly used for filtering."
  totalBalance: BigInt!

  "All investor position interactions"
  interactions: [ClassicPositionInteraction!]! @derivedFrom(field: "investorPosition")
}

enum ClassicPositionInteractionType {
  "The investor deposited funds into the vault"
  VAULT_DEPOSIT
  "The investor withdrew funds from the vault"
  VAULT_WITHDRAW
  "The investor staked in the boost of the vault and received boost shares"
  BOOST_STAKE
  "The investor unstaked from the boost of the vault and received vault shares"
  BOOST_UNSTAKE
  "The investor claimed their rewards from the vault"
  BOOST_REWARD_CLAIM
}

type ClassicPositionInteraction @entity(immutable: true) {
  "transaction hash + event log index"
  id: Bytes!

  "The Classic the investor has a position in"
  classic: Classic!
  "The investor that has a position in the Classic"
  investor: Investor!
  "The investor position the interaction is for"
  investorPosition: ClassicPosition!

  "The transaction that created the investor position interaction"
  createdWith: Transaction!

  "Block number of the interaction"
  blockNumber: BigInt!
  "The timestamp of the interaction"
  timestamp: BigInt!

  "The type of the interaction"
  type: ClassicPositionInteractionType!

  "The amount of vault shares the investor holds directly at the time of the interaction"
  vaultBalance: BigInt!
  "The amount of vault shares the investor holds in a boost at the time of the interaction"
  boostBalance: BigInt!
  "Total amount of vault shares the investor holds. Should always equal vaultBalance + boostBalance. This is mostly used for filtering."
  totalBalance: BigInt!

  "Amount of vault shares change in the interaction"
  vaultBalanceDelta: BigInt!
  "Amount of vault shares token change on the boost contract in the interaction"
  boostBalanceDelta: BigInt!
  "Amount of boost tokens change in the interaction. Ordered by classic.boostRewardTokensOrder."
  boostRewardBalancesDelta: [BigInt!]!

  "LP token price in native at the time of the interaction. Expressed with 18 decimals."
  underlyingToNativePrice: BigInt!
  "Boost token prices in native at the time of the interaction. Ordered by classic.boostRewardTokensOrder. Expressed with 18 decimals."
  boostRewardToNativePrices: [BigInt!]!
  "Native token price at the time of the interaction. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!
}

#######################
##### CLM Contracts ###
#######################

type CLM @entity {
  "The CL Manager address"
  id: Bytes!

  "The protocol the CLM belongs to"
  protocol: Protocol!
  "The manager of the CLM. The manager is responsible for accounting of a CLM."
  manager: ClmManager!
  "The strategy of the CLM. The strategy is responsible for managing the CLM's assets."
  strategy: ClmStrategy!

  "The current lifecycle status of the CLM"
  lifecycle: ProductLifecycle!

  "The manager token data of the CLM. The ClmManager is also an ERC20 token. This tokens represents the shares of the manager."
  managerToken: Token!

  "The underlying tokens contained in the CLM. This is the first token."
  underlyingToken0: Token!
  "The underlying tokens contained in the CLM. This is the second token."
  underlyingToken1: Token!

  "The output tokens of the CLM's strategy. These will be sent to the reward pool if the strategy does not automatically compound."
  outputTokens: [Token!]!
  "The output token addresses of the CLM. This is the source of truth for other tables output ordering."
  outputTokensOrder: [Bytes!]!

  # ----- PRICES & STATS -----

  "The total supply of the CLM shares token in circulation. Express with `managerToken.decimals` decimals."
  managerTotalSupply: BigInt!

  "Latest token 0 price in native we have seen. Expressed with 18 decimals."
  token0ToNativePrice: BigInt!
  "Latest token 1 price in native we have seen. Expressed with 18 decimals."
  token1ToNativePrice: BigInt!
  "Latest output token prices in native we have seen. Ordered by clm.outputTokensOrder. Expressed with 18 decimals."
  outputToNativePrices: [BigInt!]!
  "Latest native token price we have seen. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!

  """
  The current price of the token zero expressed as a token1 value.
  For example, if the CLM is a BTC/ETH CLM, this is the price of 1 BTC in ETH.
  This is expressed in token1 decimals.
  """
  priceOfToken0InToken1: BigInt!
  "Price range start this CLM is currently configured to operate in, in token 1"
  priceRangeMin1: BigInt!
  "Price range end this CLM is currently configured to operate in, in token 1"
  priceRangeMax1: BigInt!

  "Amount of underlying tokens in the CLM assigned to the main position in the first token."
  underlyingMainAmount0: BigInt!
  "Amount of underlying tokens in the CLM assigned to the main position in the second token."
  underlyingMainAmount1: BigInt!
  "Amount of underlying tokens in the CLM assigned to the alt position in the first token."
  underlyingAltAmount0: BigInt!
  "Amount of underlying tokens in the CLM assigned to the alt position in the second token."
  underlyingAltAmount1: BigInt!

  "All positions in the CLM"
  positions: [ClmPosition!]! @derivedFrom(field: "clm")

  "All collections events by the CLM"
  collections: [ClmManagerCollectionEvent!]! @derivedFrom(field: "clm")

  "All harvest events of the CLM"
  harvests: [ClmHarvestEvent!]! @derivedFrom(field: "clm")

  "Snapshot of the CLM's stats"
  snapshots: [ClmSnapshot!]! @derivedFrom(field: "clm")

  "All CLM interactions for this CLM"
  interactions: [ClmPositionInteraction!]! @derivedFrom(field: "clm")

  "Reward pools of the CLM"
  rewardPools: [RewardPool!]! @derivedFrom(field: "clm")
}

"""
A snapshot of the CLM's stats.
Any event that happens in the CLM is recorded in a snapshot.
We keep multiple snapshots time frames as noted by the "period" field.
Snapshots include: daily, weekly, yearly.
"""
type ClmSnapshot @entity {
  "CLM.id + period + timestamp"
  id: Bytes!

  "The CLM the snapshot is for"
  clm: CLM!

  """
  Duration of the snapshot period in seconds.
  Available periods:
  - 1 day: 86400
  - 1 week: 604800
  - 1 year: 31536000
  """
  period: BigInt!
  "Timestamp the snapshot was initiated at, rounded to period"
  roundedTimestamp: BigInt!
  "Actual timestamp snapshot was initiated at"
  timestamp: BigInt!

  "The total supply of the manager token in circulation. Express with `sharesToken.decimals` decimals."
  managerTotalSupply: BigInt!

  "Latest token 0 price in native of this snapshot. Expressed with 18 decimals."
  token0ToNativePrice: BigInt!
  "Latest token 1 price in native of this snapshot. Expressed with 18 decimals."
  token1ToNativePrice: BigInt!
  "Latest output token prices in native of this snapshot. Ordered by clm.outputTokensOrder. Expressed with 18 decimals."
  outputToNativePrices: [BigInt!]!
  "Latest native token price of this snapshot. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!

  """
  The current price of the token zero expressed as a token1 value.
  For example, if the CLM is a BTC/ETH CLM, this is the price of 1 BTC in ETH.
  This is expressed in token1 decimals.
  """
  priceOfToken0InToken1: BigInt!
  "Price range start this CLM is currently configured to operate in, in token 1"
  priceRangeMin1: BigInt!
  "Price range end this CLM is currently configured to operate in, in token 1"
  priceRangeMax1: BigInt!

  "Amount of underlying tokens in the CLM assigned to the main position in the first token."
  underlyingMainAmount0: BigInt!
  "Amount of underlying tokens in the CLM assigned to the main position in the second token."
  underlyingMainAmount1: BigInt!
  "Amount of underlying tokens in the CLM assigned to the alt position in the first token."
  underlyingAltAmount0: BigInt!
  "Amount of underlying tokens in the CLM assigned to the alt position in the second token."
  underlyingAltAmount1: BigInt!
}

"""
A ClmManager handles the accounting of a CLM.
"""
type ClmManager @entity {
  "The CL Manager address"
  id: Bytes!
  "The CLM this manager belongs to"
  clm: CLM!
  "The transaction that created the manager"
  createdWith: Transaction!
  "Technical field to remember if the CLM was already initialized"
  isInitialized: Boolean!
}

"""
A strategy is a contract that manages the assets of a CLM.
This entity is mostly used to start tracking the events and link them to the CLM on new event
"""
type ClmStrategy @entity {
  "The strategy address"
  id: Bytes!
  "The CLM the strategy is managing"
  clm: CLM!
  "The manager of the strategy"
  manager: ClmManager!
  "The output token sent to the reward pool. Set to NULL token if the strategy automatically compounds."
  outputToken: Token!
  "The transaction that created the strategy"
  createdWith: Transaction!
  "Technical field to remember if the strategy was already initialized"
  isInitialized: Boolean!
}

"""
ClmManagers are harvested by the strategy. This event is emitted when the strategy harvests the manager.
"""
type ClmHarvestEvent @entity(immutable: true) {
  "transaction hash + log index"
  id: Bytes!

  "The CLM the harvest event is for"
  clm: CLM!
  "The strategy that harvested the Manager"
  strategy: ClmStrategy!

  "The transaction that created the harvest event"
  createdWith: Transaction!

  "The event log index in the transaction that created the harvest event."
  logIndex: BigInt!

  "The timestamp of the harvest event so you can sort by time"
  timestamp: BigInt!

  "Underlying balance of the first token after the harvest"
  underlyingAmount0: BigInt!
  "Underlying balance of the second token after the harvest"
  underlyingAmount1: BigInt!

  "The amount of first underlying tokens compounded"
  compoundedAmount0: BigInt!
  "The amount of second underlying tokens compounded"
  compoundedAmount1: BigInt!
  "The amount of output tokens collected. Ordered by clm.outputTokensOrder."
  collectedOutputAmounts: [BigInt!]!

  "Total amount of liquidity in the manager at time of harvest"
  managerTotalSupply: BigInt!

  "Token 0 price in native at the time of harvest. Expressed with 18 decimals."
  token0ToNativePrice: BigInt!
  "Token 1 price in native at the time of harvest. Expressed with 18 decimals."
  token1ToNativePrice: BigInt!
  "Output token prices in native at the time of harvest. Expressed with 18 decimals. Ordered by clm.outputTokensOrder."
  outputToNativePrices: [BigInt!]!
  "Native token price at the time of harvest. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!
}

"""
This event is emitted when we collect earned trading fees from the underlying pool.
"""
type ClmManagerCollectionEvent @entity(immutable: true) {
  "transaction hash + log index"
  id: Bytes!

  "The CLM the collect event is for"
  clm: CLM!
  "The strategy that collect for the Manager"
  strategy: ClmStrategy!

  "The transaction that created the collect event"
  createdWith: Transaction!

  "The event log index in the transaction that created the collection event."
  logIndex: BigInt!

  "The timestamp of the collect event so you can sort by time"
  timestamp: BigInt!

  "Amount of underlying tokens in the CLM assigned to the main position in the first token."
  underlyingMainAmount0: BigInt!
  "Amount of underlying tokens in the CLM assigned to the main position in the second token."
  underlyingMainAmount1: BigInt!
  "Amount of underlying tokens in the CLM assigned to the alt position in the first token."
  underlyingAltAmount0: BigInt!
  "Amount of underlying tokens in the CLM assigned to the alt position in the second token."
  underlyingAltAmount1: BigInt!

  "Amount of collected fees in the first token"
  collectedAmount0: BigInt!
  "Amount of collected fees in the second token"
  collectedAmount1: BigInt!
  "Amount of collected fees in the output tokens. Ordered by clm.outputTokensOrder."
  collectedOutputAmounts: [BigInt!]!

  "Token 0 price in native at the time of the collection. Expressed with 18 decimals."
  token0ToNativePrice: BigInt!
  "Token 1 price in native at the time of the collection. Expressed with 18 decimals."
  token1ToNativePrice: BigInt!
  "Output token prices in native at the time of the collection. Expressed with 18 decimals. Ordered by clm.outputTokensOrder."
  outputToNativePrices: [BigInt!]!
  "Native token price at the time of the interaction. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!
}

"""
An investor position is a record of an investor's position in a CLM.
"""
type ClmPosition @entity {
  "CLM.id + investor address"
  id: Bytes!

  "The CLM the investor has a position in"
  clm: CLM!
  "The investor that has a position in the CLM"
  investor: Investor!
  "The transaction that created the investor position"
  createdWith: Transaction!

  "The amount of manager shares the investor holds"
  managerBalance: BigInt!
  "Total amount of CLM shares the investor holds. Should always equal to managerBalance + rewardPoolBalance. This is mostly used for filtering."
  totalBalance: BigInt!

  "All investor position interactions"
  interactions: [ClmPositionInteraction!]! @derivedFrom(field: "investorPosition")
}

enum ClmPositionInteractionType {
  "The investor deposited funds into the CLM"
  MANAGER_DEPOSIT
  "The investor withdrew funds from the CLM"
  MANAGER_WITHDRAW
}

type ClmPositionInteraction @entity(immutable: true) {
  "transaction hash + event log index"
  id: Bytes!

  "The CLM the investor has a position in"
  clm: CLM!
  "The investor that has a position in the CLM"
  investor: Investor!
  "The investor position the interaction is for"
  investorPosition: ClmPosition!

  "The transaction that created the investor position interaction"
  createdWith: Transaction!

  "Block number of the interaction"
  blockNumber: BigInt!
  "The timestamp of the interaction"
  timestamp: BigInt!

  "The type of the interaction"
  type: ClmPositionInteractionType!

  "The amount of manager shares the investor holds at the time of the interaction"
  managerBalance: BigInt!
  "Total amount of CLM shares the investor holds. Should always equal to managerBalance + rewardPoolBalance. This is mostly used for filtering."
  totalBalance: BigInt!
  "The amount of first underlying tokens the investor is entitled to at the time of the interaction"
  underlyingBalance0: BigInt!
  "The amount of second underlying tokens the investor is entitled to at the time of the interaction"
  underlyingBalance1: BigInt!

  "Amount of manager shares change in the interaction"
  managerBalanceDelta: BigInt!
  "Amount of underlying token 0 change in the interaction"
  underlyingBalance0Delta: BigInt!
  "Amount of underlying token 0 change in the interaction"
  underlyingBalance1Delta: BigInt!

  "Token 0 price in native at the time of the interaction. Expressed with 18 decimals."
  token0ToNativePrice: BigInt!
  "Token 1 price in native at the time of the interaction. Expressed with 18 decimals."
  token1ToNativePrice: BigInt!
  "Output token prices in native at the time of the interaction. Expressed with 18 decimals. Ordered by clm.outputTokensOrder."
  outputToNativePrices: [BigInt!]!
  "Native token price at the time of the interaction. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!
}

###############################
##### Reward Pool Contracts ###
###############################

type RewardPool @entity {
  "The reward pool address"
  id: Bytes!

  "The protocol the reward pool belongs to"
  protocol: Protocol!

  "The current lifecycle status of the reward pool"
  lifecycle: ProductLifecycle!
  "The transaction that created this reward pool"
  createdWith: Transaction!

  "The CLM this reward pool applies to."
  clm: CLM
  "The classic vault this reward pool applies to."
  classic: Classic

  "The reward pool's share token"
  shareToken: Token!

  "The reward pool reward tokens. Tokens earned by staking in the reward pool."
  rewardTokens: [Token!]!
  "The reward pool reward token addresses. This is the source of truth for other tables reward ordering."
  rewardTokensOrder: [Bytes!]!

  "The reward pool's underlying LP token. This can be a classic vault or a CLM manager"
  underlyingToken: Token!

  # ----- PRICES & STATS -----

  "The total supply of the reward pool shares token in circulation. Express with `sharesToken.decimals` decimals."
  sharesTotalSupply: BigInt!

  "Latest LP token price in native we have seen. Expressed with 18 decimals."
  underlyingToNativePrice: BigInt!
  "Latest reward token prices in native we have seen. Ordered by rewardPool.rewardTokensOrder. Expressed with 18 decimals."
  rewardToNativePrices: [BigInt!]!
  "Latest native token price we have seen. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!

  "Amount of underlying token in the reward pool"
  underlyingAmount: BigInt!

  "All positions in the Reward Pool"
  positions: [RewardPoolPosition!]! @derivedFrom(field: "rewardPool")

  "Snapshot of the Reward Pool's stats"
  snapshots: [RewardPoolSnapshot!]! @derivedFrom(field: "rewardPool")

  "All Reward Pool interactions for this Reward Pool"
  interactions: [RewardPoolPositionInteraction!]! @derivedFrom(field: "rewardPool")
}

"""
A snapshot of the Reward Pool's stats.
Any event that happens in the Reward Pool is recorded in a snapshot.
We keep multiple snapshots time frames as noted by the "period" field.
Snapshots include: daily, weekly, yearly.
"""
type RewardPoolSnapshot @entity {
  "RewardPool.id + period + timestamp"
  id: Bytes!

  "The Reward Pool the snapshot is for"
  rewardPool: RewardPool!

  """
  Duration of the snapshot period in seconds.
  Available periods:
  - 1 day: 86400
  - 1 week: 604800
  - 1 year: 31536000
  """
  period: BigInt!
  "Timestamp the snapshot was initiated at, rounded to period"
  roundedTimestamp: BigInt!
  "Actual timestamp snapshot was initiated at"
  timestamp: BigInt!

  "The total supply of the reward pool shares token in circulation. Express with `sharesToken.decimals` decimals."
  sharesTotalSupply: BigInt!

  "Latest LP token price in native of this snapshot. Expressed with 18 decimals."
  underlyingToNativePrice: BigInt!
  "Latest reward token prices in native of this snapshot. Ordered by rewardPool.rewardTokensOrder. Expressed with 18 decimals."
  rewardToNativePrices: [BigInt!]!
  "Latest native token price of this snapshot. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!

  "Amount of underlying tokens in the reward pool"
  underlyingAmount: BigInt!
}

"""
An investor position is a record of an investor's position in a Reward Pool.
"""
type RewardPoolPosition @entity {
  "RewardPool.id + investor address"
  id: Bytes!

  "The Reward Pool the investor has a position in"
  rewardPool: RewardPool!
  "The investor that has a position in the Reward Pool"
  investor: Investor!
  "The transaction that created the investor position"
  createdWith: Transaction!

  "The amount of reward pool shares the investor holds"
  sharesBalance: BigInt!
  "Total amount of reward pool shares the investor holds. This is mostly used for filtering."
  totalBalance: BigInt!

  "All investor position interactions"
  interactions: [RewardPoolPositionInteraction!]! @derivedFrom(field: "investorPosition")
}

enum RewardPoolPositionInteractionType {
  "The investor deposited funds into the Reward Pool"
  REWARD_POOL_DEPOSIT
  "The investor withdrew funds from the Reward Pool"
  REWARD_POOL_WITHDRAW
  "The investor claimed their rewards from the Reward Pool"
  REWARD_CLAIM
}

type RewardPoolPositionInteraction @entity(immutable: true) {
  "transaction hash + event log index"
  id: Bytes!

  "The Reward Pool the investor has a position in"
  rewardPool: RewardPool!
  "The investor that has a position in the Reward Pool"
  investor: Investor!
  "The investor position the interaction is for"
  investorPosition: RewardPoolPosition!

  "The transaction that created the investor position interaction"
  createdWith: Transaction!

  "Block number of the interaction"
  blockNumber: BigInt!
  "The timestamp of the interaction"
  timestamp: BigInt!

  "The type of the interaction"
  type: RewardPoolPositionInteractionType!

  "The amount of reward pool shares the investor holds at the time of the interaction"
  sharesBalance: BigInt!
  "Total amount of reward pool shares the investor holds. This is mostly used for filtering."
  totalBalance: BigInt!
  "Amount of underlying token the investor is entitled to at the time of the interaction"
  underlyingBalance: BigInt!

  "Amount of reward pool shares change in the interaction"
  sharesBalanceDelta: BigInt!
  "Amount of reward tokens change in the interaction. Ordered by rewardPool.rewardTokensOrder."
  rewardBalancesDelta: [BigInt!]!
  "Amount of underlying token change in the interaction"
  underlyingBalanceDelta: BigInt!

  "LP token price in native at the time of the interaction. Expressed with 18 decimals."
  underlyingToNativePrice: BigInt!
  "Reward token prices in native at the time of the interaction. Expressed with 18 decimals."
  rewardToNativePrices: [BigInt!]!
  "Native token price at the time of the interaction. Expressed with 18 decimals."
  nativeToUSDPrice: BigInt!
}
